#!/usr/bin/env python

import os
from bsdconv import *
from gi.repository import Gtk

items = Gtk.TreeStore(int, str, str, str, str, str, str, str, str, str, str)
attr_map={
	'selected':	0,	#0=no, 1=yes, -1=not_in_zone
	'name0':	1,
	'info':		2,
	'name2':	3,	#used by naming operation
	'name1':	4,	#name2 or name0 if there are duplication or collision
	'uname0':	5,	#utf8er(name0)
	'uname1':	6,	#utf8er(name1)
	'uname2':	7,	#utf8er(name2)
	'error_counter':8,
	'collision':	9,
	'duplication':	10
}

class Item(object):
	def __init__(self, iter):
		self.item=items[iter]

	def __getattr__(self, key):
		if key in attr_map:
			return self.item[attr_map[key]]
		else:
			return super(Item, self).__getattr__(key)

	def __setattr__(self, key, value):
		if key in attr_map:
			self.item[attr_map[key]]=value
		else:
			super(Item, self).__setattr__(key, value)

class gBsdConv(object):
	def __init__(self):

		self.builder = builder = Gtk.Builder()
		builder.add_from_file("gbsdconv.xml")
		self.window = builder.get_object("main_window")
		self.window.connect("delete-event", Gtk.main_quit)
		self.utf8er = Bsdconv('utf-8,3f:utf-8,3f')
		builder.get_object("conversion").set_text("BYTE:BYTE")

		#Global objects
		self.counter = 0
		self.err_counter = 0
		self.err_counter_selected = 0
		self.collision = 0
		self.duplication = 0
		self.converter = Bsdconv("BYTE:BYTE")		
		
		self.inter_codecs = {}

		main_tabs = builder.get_object("main_tabs")
		main_tabs.connect("switch-page", self.main_tabs_cb)

		operation_tabs = builder.get_object("operation_tabs")
		operation_tabs.connect("switch-page", self.operation_tabs_cb)

		self.item_tab_init()
		self.conversion_tab_init()
		self.operation_text_tab_init()
		self.operation_naming_tab_init()
		self.operation_content_tab_init()

		#launch
		self.window.show()

	#Callbacks
	def main_tabs_cb(self, notebook, page, pagen):
		operation_tabs = self.builder.get_object("operation_tabs")
		operation_curr_page = operation_tabs.get_nth_page(operation_tabs.get_current_page())
		if page == operation_tabs:
			if operation_curr_page == self.builder.get_object("operation_naming_page"):
				self.naming_cb()
			elif operation_curr_page == self.builder.get_object("operation_content_page"):
				self.content_cb()


	#Callbacks for items tab
	def item_tab_init(self):
		items_view = self.builder.get_object("items")
		toggle=Gtk.CellRendererToggle()
		toggle.connect("toggled", self.items_toggle_cb)
		items_view.insert_column_with_data_func(0, "#", toggle, self.items_toggle_render_cb, 0)
		items_path=Gtk.TreeViewColumn("Path", Gtk.CellRendererText(), text=attr_map['uname0'])
		items_view.append_column(items_path)
		items_view.set_expander_column(items_path)
		items_view.set_model(items)

		item_add = self.builder.get_object("item_add")
		item_add.connect("clicked", self.item_add_cb)

		item_add_r = self.builder.get_object("item_add_r")
		item_add_r.connect("clicked", self.item_add_cb)

		item_remove = self.builder.get_object("item_remove")
		item_remove.connect("clicked", self.item_remove_cb)

	def item_add_cb(self, obj):
		builder = self.builder
		recur = obj==builder.get_object("item_add_r")
		for path in builder.get_object("item_chooser").get_filenames():
			self.item_add_cb_r(path, recur)

		builder.get_object("items").expand_all()
		builder.get_object("content_items").expand_all()

	def item_add_cb_r(self, path, recur):
		self.item_add_cb_sub(path)
		if recur and os.path.isdir(path):
			for spath in os.listdir(path):
				self.item_add_cb_r(os.path.join(path, spath), recur)

	def item_add_cb_sub(self, path):
		a=[path]
		while len(a[attr_map['selected']])>1:
			t=a.pop(0)
			p, q = os.path.split(t)
			a.insert(0, q)
			a.insert(0, p)
		parent = None
		for i in xrange(0, len(a)):
			p=a[i]
			curr = items.iter_children(parent)
			while curr != None:
				item=Item(curr)
				if p==item.name0:
					parent = curr
					break
				curr = items.iter_next(curr)
			if curr == None:
				if i==len(a)-1:
					selected=1
				else:
					selected=-1
				parent = items.append(parent, [selected, p, '', '', '', self.utf8er.conv(p), '', '', '', '', ''])

	def item_remove_cb(self, obj):
		model, treeiter = self.builder.get_object("items").get_selection().get_selected()
		if treeiter:
			model.remove(treeiter)

	#Callbacks for conversion tab
	def conversion_tab_init(self):
		self.from_codecs = Gtk.ListStore(str)
		self.inter_codecs = Gtk.ListStore(str)
		self.to_codecs = Gtk.ListStore(str)

		codecs=codecs_list(FROM)
		for codec in codecs:
			self.from_codecs.append([codec])
		codecs=codecs_list(INTER)
		for codec in codecs:
			self.inter_codecs.append([codec])
		codecs=codecs_list(TO)
		for codec in codecs:
			self.to_codecs.append([codec])

		text_convert = self.builder.get_object("conversion_generate")
		text_convert.connect("clicked", self.generate_cb)

		self.builder.get_object("conversion").connect("changed", self.conversion_apply_cb)

		self.builder.get_object("conversion_add").connect('clicked', self.conversion_add_cb)
		self.builder.get_object("conversion_add").clicked()
	def generate_cb(self, obj):
		conversion=[]
		builder = self.builder

		conversion.append(builder.get_object("from_codecs").get_active_text())

		ignoring_whitespaces=builder.get_object("chk_ignoring_whitespace")

		if ignoring_whitespaces.get_active():
			conversion.append('WHITESPACE-DERAIL')

		if ignoring_whitespaces.get_active():
			conversion.append('WHITESPACE-RERAIL')

		conversion.append(builder.get_object("to_codecs").get_active_text())

		print builder.get_object("to_codecs")
		print conversion
		builder.get_object("conversion").set_text(':'.join(conversion))

	def conversion_apply_cb(self, obj):
		self.converter = Bsdconv(self.builder.get_object("conversion").get_text())
		if self.converter:
			self.set_status(str(self.converter))
		else:
			self.set_status(error())

	def codecs_list_cb(self, obj):
		print obj.get_label()

	def conversion_add_cb(self, obj):
		conversion = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
		conversion.set_visible(True)
		self.builder.get_object('conversions').pack_start(conversion, False, False, 0)
		for codecs in (self.from_codecs, self.inter_codecs, self.to_codecs):
			obj_codecs=Gtk.ComboBox.new_with_model(codecs)
			obj_codecs.set_visible(True)
			conversion.pack_start(obj_codecs, False, False, 0)
			renderer=Gtk.CellRendererText()
			obj_codecs.pack_start(renderer, False)
			obj_codecs.add_attribute(renderer, "text", 0)
			obj_codecs.set_active(0)

	#Callbacks for operation tab
	#+Text
	def operation_text_tab_init(self):
		text_origin_buffer = self.builder.get_object("text_origin").get_buffer()
		text_origin_buffer.connect("changed", self.text_cb)

	def text_cb(self, obj):
		builder = self.builder
		if not self.converter:
			return
		i=builder.get_object("text_origin").get_buffer()
		o=builder.get_object("text_result").get_buffer()
		cnt = i.get_text(i.get_start_iter(), i.get_end_iter(), 0)
		o.set_text(cnt)
		o.set_text(self.utf8er.conv(self.converter.conv(cnt)))
		info=self.converter.info()
		self.set_status('ierr:%d oerr:%d' % (info['ierr'], info['oerr']))

	#+Naming
	def operation_naming_tab_init(self):
		naming = self.builder.get_object("naming")

		toggle=Gtk.CellRendererToggle()
		toggle.connect("toggled", self.naming_items_toggle_cb)
		naming.insert_column_with_data_func(0, "#", toggle, self.items_toggle_render_cb, 0)

		renderer = Gtk.CellRendererText()
		items_path = Gtk.TreeViewColumn("Path", renderer, text=attr_map['uname0'])
		items_path.set_resizable(True)
		naming.append_column(items_path)
		naming.set_expander_column(items_path)

		renderer = Gtk.CellRendererText()
		items_path2 = Gtk.TreeViewColumn("Result", renderer, text=attr_map['uname1'])
		items_path2.set_resizable(True)
		naming.append_column(items_path2)

		renderer = Gtk.CellRendererText()
		info = Gtk.TreeViewColumn("Info", renderer, text=attr_map['info'])
		naming.append_column(info)

		naming.set_model(items)

		self.builder.get_object('naming_convert').connect('clicked', self.naming_convert)

	def operation_tabs_cb(self, notebook, page, pagen):
		if page == self.builder.get_object("operation_naming_page"):
			self.naming_cb()
		elif page == self.builder.get_object("operation_content_page"):
			self.content_cb()

	def naming_cb(self):
		if not self.converter:
			return
		naming = self.builder.get_object("naming")
		self.err_counter=0
		self.err_counter_selected=0
		self.collision=0
		self.duplication=0
		self.naming_cb_r(None)
		self.set_status('Error: %d Collision: %d Duplication: %d' % (self.err_counter_selected, self.collision, self.duplication))
		naming.expand_all()

	def naming_cb_r(self, parent):
		curr = items.iter_children(parent)
		pool={}
		while curr != None:
			item=Item(curr)
			item.error_counter=''
			item.collision=''
			item.duplication=''
			if item.selected>0:
				newname=self.converter.conv(item.name0)
				item.name2=newname
				item.uname2=self.utf8er.conv(item.name2)
				item.name1=item.name2
				info=self.converter.info()
				if info['ierr']+info['oerr']>0:
					item.error_counter=str(info['ierr']+info['oerr'])
					self.err_counter_selected+=1
				if newname in pool:
					item.collision='C'
					self.collision+=1
					if Item(pool[newname]).collision!='C':
						Item(pool[newname]).collision='C'
						self.collision+=1
					self.geninfo(pool[newname])
					item.name1=item.name0
				else:
					pool[newname]=curr
				newpath = self.getFullNewPath(curr)
				if newname!=item.name0 and os.path.exists(newpath):
					item.duplication='D'
					self.duplication+=1
					item.name1=item.name0
				item.uname1=self.utf8er.conv(item.name1)
			elif item.selected==0:
				item.name1=item.name0
				item.uname1=self.utf8er.conv(item.name1)
			self.geninfo(curr)
			if items.iter_has_child(curr):
				self.naming_cb_r(curr)
			curr = items.iter_next(curr)

	def getFullNewPath(self, ti):
		ret=[]
		if not ti:
			return ''
		item=Item(ti)
		ret.insert(0, item.name2)
		ti = items.iter_parent(ti)
		while ti!=None:
			if item.selected>=0:
				ret.insert(0, item.name1)
			else:
				ret.insert(0, item.name0)
			ti = items.iter_parent(ti)
		return os.path.join(*ret)

	def naming_items_toggle_cb(self, renderer, path):
		iter=items.get_iter(path)
		item=Item(iter)
		if item.selected:
			item.selected=0
			
		else:
			item.selected=1
		self.naming_cb_r(items.iter_parent(iter))

	def naming_convert(self, obj):
		if not self.converter:
			return
		self.counter=0
		self.naming_convert_r(None)
		self.set_status('%d dirs/files converted' % self.counter)
		
	def naming_convert_r(self, parent):
		curr = items.iter_children(parent)
		while curr != None:
			if items.iter_has_child(curr):
				self.naming_convert_r(curr)
			item=Item(curr)
			if item.selected>0 and item.name0!=item.name1:
				os.chdir(os.path.dirname(self.getFullPath(curr)))
				os.rename(item.name0, item.name1)
				self.counter+=1
			curr = items.iter_next(curr)

	#+Content
	def operation_content_tab_init(self):
		content_items = self.builder.get_object("content_items")
		toggle=Gtk.CellRendererToggle()
		toggle.connect("toggled", self.items_toggle_cb)
		content_items.insert_column_with_data_func(0, "#", toggle, self.items_toggle_render_cb, 0)

		renderer = Gtk.CellRendererText()
		items_path = Gtk.TreeViewColumn("Path", renderer, text=attr_map['uname0'])
		items_path.set_expand(True)
		content_items.append_column(items_path)
		content_items.set_expander_column(items_path)

		renderer = Gtk.CellRendererText()
		items_info = Gtk.TreeViewColumn("Info", renderer, text=attr_map['info'])
		content_items.append_column(items_info)

		content_items.set_model(items)

		content_items_select = content_items.get_selection()
		content_items_select.connect("changed", self.content_items_select_cb)

		self.builder.get_object('content_convert').connect('clicked', self.content_convert)

	def content_items_select_cb(self, obj):
		builder = self.builder
		model, treeiter = obj.get_selected()
		if treeiter != None:
			fullpath = self.getFullPath(treeiter)
			if os.path.isfile(fullpath):
				f=open(fullpath,'r')
				cnt=f.read()
				builder.get_object("content_origin").get_buffer().set_text(self.utf8er.conv(cnt))
				f.close()
				if not self.converter:
					return
				builder.get_object("content_result").get_buffer().set_text(self.utf8er.conv(self.converter.conv(cnt)))
			else:
				self.set_status("%s is not a file" % fullpath)

	def content_cb(self):
		if not self.converter:
			return
		self.err_counter=0
		self.err_counter_selected=0
		self.content_cb_r(None)
		self.set_status('Error: %d (Selected: %d)' % (self.err_counter, self.err_counter_selected))

	def content_cb_r(self, parent):
		curr = items.iter_children(parent)
		while curr != None:
			item=Item(curr)
			fullpath=self.getFullPath(curr)
			if item.selected>=0 and os.path.isfile(fullpath):
				self.converter.testconv_file(fullpath)
				info=self.converter.info()
				err=info['ierr']+info['oerr']
				if err>0:
					item.info=str(err)
					self.err_counter+=1
					if item.selected>0:
						self.err_counter_selected+=1
				else:
					item.info=''
			if items.iter_has_child(curr):
				self.content_cb_r(curr)
			curr = items.iter_next(curr)

	def content_convert(self, obj):
		if not self.converter:
			return
		self.counter=0
		self.content_convert_r(None)
		self.set_status('%d files converted' % self.counter)
		
	def content_convert_r(self, parent):
		curr = items.iter_children(parent)
		while curr != None:
			item=Item(curr)
			if item.selected>0:
				fpath=self.getFullPath(curr)
				self.converter.conv_file(fpath, fpath)
				self.counter+=1
			if items.iter_has_child(curr):
				self.content_convert_r(curr)
			curr = items.iter_next(curr)

	#helper
	def set_status(self, s):
		status=self.builder.get_object('status')
		status.remove_all(0)
		status.push(0, s)

	def items_toggle_render_cb(self, column, cell, model, iter, arg):
		item=Item(iter)
		if item.selected==-1:
			cell.set_visible(False)
		else:
			cell.set_visible(True)
			if item.selected==0:
				cell.set_active(False)
			else:
				cell.set_active(True)

	def items_toggle_cb(self, renderer, path):
		iter=items.get_iter(path)
		item=Item(iter)
		if item.selected:
			item.selected=0
		else:
			item.selected=1

	def getFullPath(self, ti):
		ret=[]
		while ti!=None:
			item=Item(ti)
			ret.insert(0, item.name0)
			ti = items.iter_parent(ti)
		return os.path.join(*ret)

	def geninfo(self, curr):
		item=Item(curr)
		item.info=''.join((item.error_counter,item.collision,item.duplication))

if __name__ == "__main__":
	app = gBsdConv()
	Gtk.main()
