#!/usr/bin/env python

import os
from bsdconv import *
from gi.repository import Gtk

class gBsdConv(object):       
	def __init__(self):
		self.builder = builder = Gtk.Builder()
		builder.add_from_file("gbsdconv.xml")
		self.window = builder.get_object("main_window")
		self.window.connect("delete-event", Gtk.main_quit)
		builder.get_object("conversion").set_text("BYTE:BYTE")

		#Global objects
		self.converter = Bsdconv("BYTE:BYTE")
		self.items = Gtk.TreeStore(str)
		self.inter_codecs = {}

		main_tabs = builder.get_object("main_tabs")
		main_tabs.connect("switch-page", self.main_tabs_cb)

		operation_tabs = builder.get_object("operation_tabs")
		operation_tabs.connect("switch-page", self.operation_tabs_cb)

		#Items tab
		items = builder.get_object("items")
		items.append_column(Gtk.TreeViewColumn("Path", Gtk.CellRendererText(), text=0))
		items.set_model(self.items)

		item_add = builder.get_object("item_add")
		item_add.connect("clicked", self.item_add_cb)

		item_add_r = builder.get_object("item_add_r")
		item_add_r.connect("clicked", self.item_add_cb)

		item_remove = builder.get_object("item_remove")
		item_remove.connect("clicked", self.item_remove_cb)

		#Conversion tab
		#+Express
		#++from
		from_codecs = builder.get_object("from_codecs")
		for codec in ['UTF-8,ASCII','BIG5,ASCII','GBK,ASCII','ISO-8859-1,ASCII']:
			from_codecs.append_text(codec)
		from_codecs.set_active(0)

		#++inter
		inter_codecs = builder.get_object("inter_codecs")
		for text, codecs in [
			["Ignoring Whitespaces", ["WHITESPACE-DERAIL","WHITESPACE-RERAIL"]],
			["Trad", ["ZHTW", "ZHTW_WORDS"]],
			["Sim", ["ZHCN"]],
		]:
			t = Gtk.CheckButton(text)
			self.inter_codecs[text]=t
			inter_codecs.pack_start(t, False, True, 0)
			t.show()

		#++to
		to_codecs = builder.get_object("to_codecs")
		for codec in ['UTF-8,ASCII','BIG5,ASCII','GBK,ASCII','ISO-8859-1,ASCII']:
			to_codecs.append_text(codec)
		to_codecs.set_active(0)

		text_convert = builder.get_object("conversion_generate")
		text_convert.connect("clicked", self.generate_cb)

		conversion_apply = builder.get_object("conversion_apply")
		conversion_apply.connect("clicked", self.conversion_apply_cb)

		#+List
		codecs=codecs_list()

		for t in ("from","inter","to"):
			_list = builder.get_object("%s_codecs_list" % t)
			for codec in codecs[t]:
				t = Gtk.Button(codec)
				t.connect("clicked", self.codecs_list_cb)
				_list.pack_start(t, False, True, 0)
				t.show()

		#Operation tab
		#+Text tab
		text_origin_buffer = builder.get_object("text_origin").get_buffer()
		text_origin_buffer.connect("changed", self.text_cb)

		#+Naming tab
		naming_origin = builder.get_object("naming_origin")
		renderer = Gtk.CellRendererText()
		column = Gtk.TreeViewColumn("Path", renderer, text=0)
		naming_origin.append_column(column)
		naming_origin.set_model(self.items)

		naming_result = builder.get_object("naming_result")
		renderer = Gtk.CellRendererText()
		column = Gtk.TreeViewColumn("Path", renderer, text=0)
		naming_result.append_column(column)

		#+Content tab
		content_items = builder.get_object("content_items")
		renderer = Gtk.CellRendererText()
		column = Gtk.TreeViewColumn("Path", renderer, text=0)
		content_items.append_column(column)
		content_items.set_model(self.items)

		content_items_select = content_items.get_selection()
		content_items_select.connect("changed", self.content_items_select_cb)

		#launch
		self.window.show()

	#Callbacks
	def main_tabs_cb(self, notebook, page, pagen):
		operation_tabs = self.builder.get_object("operation_tabs")
		operation_curr_page = operation_tabs.get_nth_page(operation_tabs.get_current_page())
		if page == operation_tabs and operation_curr_page == self.builder.get_object("operation_naming_page"):
			self.naming_cb()

	#Callbacks for items tab
	def item_add_cb(self, obj):
		builder = self.builder
		recur = obj==builder.get_object("item_add_r")
		for path in builder.get_object("item_chooser").get_filenames():
			self.item_add_cb_r(path, recur)

	def item_add_cb_r(self, path, recur):
		self.item_add_cb_sub(path)
		if recur and os.path.isdir(path):
			for spath in os.listdir(path):
				self.item_add_cb_r(os.path.join(path, spath), recur)

	def item_add_cb_sub(self, path):
		a=[path]
		while len(a[0])>1:
			t=a.pop(0)
			p, q = os.path.split(t)
			a.insert(0, q)
			a.insert(0, p)
		parent = None
		for p in a:
			curr = self.items.iter_children(parent)
			while curr != None:
				if p==self.items[curr][0]:
					parent = curr
					break
				curr = self.items.iter_next(curr)
			if curr == None:
				parent = self.items.append(parent, [p])

	def item_remove_cb(self, obj):
		builder = self.builder
		model, treeiter = builder.get_object("items").get_selection().get_selected()
		model.remove(treeiter)

	#Callbacks for conversion tab
	def generate_cb(self, obj):
		conversion=[]
		builder = self.builder

		conversion.append(builder.get_object("from_codecs").get_active_text())

		ignoring_whitespaces=builder.get_object("chk_ignoring_whitespace")

		if ignoring_whitespaces.get_active():
			conversion.append('WHITESPACE-DERAIL')

		if ignoring_whitespaces.get_active():
			conversion.append('WHITESPACE-RERAIL')

		conversion.append(builder.get_object("to_codecs").get_active_text())

		print builder.get_object("to_codecs")
		print conversion
		builder.get_object("conversion").set_text(':'.join(conversion))

	def conversion_apply_cb(self, obj):
		self.converter = Bsdconv(self.builder.get_object("conversion").get_text())

	def codecs_list_cb(self, obj):
		print obj.get_label()

	#Callbacks for operation tab
	#+Text
	def text_cb(self, obj):
		builder = self.builder
		if not self.converter:
			return
		i=builder.get_object("text_origin").get_buffer()
		o=builder.get_object("text_result").get_buffer()
		cnt = i.get_text(i.get_start_iter(), i.get_end_iter(), 0)
		o.set_text(cnt)
		o.set_text(self.converter.conv(cnt))

	#+Naming
	def operation_tabs_cb(self, notebook, page, pagen):
		if page == self.builder.get_object("operation_naming_page"):
			self.naming_cb()

	def naming_cb(self):
		if not self.converter:
			return
		naming_result = self.builder.get_object("naming_result")
		naming_result_store = Gtk.TreeStore(str)
		naming_result.set_model(naming_result_store)

		self.naming_cb_r(naming_result_store, None, None)

	def naming_cb_r(self, store, fparent, tparent):
		fcurr = self.items.iter_children(fparent)
		while fcurr != None:
			tcurr = store.append(tparent, [self.converter.conv(self.items[fcurr][0])])
			if self.items.iter_has_child(fcurr):
				self.naming_cb_r(store, fcurr, tcurr)
			fcurr = self.items.iter_next(fcurr)

	#+Content
	def content_items_select_cb(self, obj):
		builder = self.builder
		model, treeiter = obj.get_selected()
		if treeiter != None:
			filename = self.getFullPath(model, treeiter)
			if os.path.isfile(filename):
				f=open(filename,'r')
				cnt=f.read()
				builder.get_object("content_origin").get_buffer().set_text(cnt)
				f.close()
				if not self.converter:
					return
				builder.get_object("content_result").get_buffer().set_text(self.converter.conv(cnt))

	#helper
	def getFullPath(self, model, ti):
		ret=[]
		while ti!=None:
			ret.insert(0, model[ti][0])
			ti = model.iter_parent(ti)
		return os.path.join(*ret)


if __name__ == "__main__":
	app = gBsdConv()
	Gtk.main()
